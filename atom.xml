<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Devin&#39;s Blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://devinnn.github.io/"/>
  <updated>2017-10-17T06:16:47.149Z</updated>
  <id>https://devinnn.github.io/</id>
  
  <author>
    <name>Devin</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>前端移动端适配总结</title>
    <link href="https://devinnn.github.io/article/2017/10/17/%E5%89%8D%E7%AB%AF%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D%E6%80%BB%E7%BB%93/"/>
    <id>https://devinnn.github.io/article/2017/10/17/前端移动端适配总结/</id>
    <published>2017-10-17T03:26:56.000Z</published>
    <updated>2017-10-17T06:16:47.149Z</updated>
    
    <content type="html"><![CDATA[<h3 id="meta标签到底做了什么事情"><a href="#meta标签到底做了什么事情" class="headerlink" title="meta标签到底做了什么事情"></a>meta标签到底做了什么事情</h3><p>做过移动端适配的小伙伴一定有遇到过这行代码：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt;</code></pre><p>但是，很多小伙伴只是感性的认识：噢，我加了这行代码，然后页面的宽度就会跟我的设备宽度一致。然而，这种理解是很片面的。那么，这句话的本质到底是什么呢？</p><p>不急，我们先往下面看，这里先留个悬念。</p><h4 id="几个专有名词和单位"><a href="#几个专有名词和单位" class="headerlink" title="几个专有名词和单位"></a>几个专有名词和单位</h4><p>这里，我们先来辨析一下在适配的时候经常会遇到的一些名词、数值单位。</p><p>首先，先来看一下<strong>物理像素</strong>。<br><a id="more"></a><br>以iphone6为例，可知道：</p><p><strong>分辨率</strong>：1334pt x 750pt<br>指的是屏幕上垂直有1136个物理像素，水平有750个物理像素。</p><p><strong>屏幕尺寸</strong>：4.7in<br>注意英寸是长度单位，不是面积单位。4.7英寸指的是屏幕对角线的长度，1英寸等于2.54cm。</p><p><strong>屏幕像素密度</strong>：326ppi<br>指的是每英寸屏幕所拥有的像素数，在显示器中，dpi=ppi。dpi强调的是每英寸多少点。同时，<strong>屏幕像素密度</strong>=<strong>分辨率</strong>/<strong>屏幕尺寸</strong></p><p>接着，我们来看一下其他的单位。</p><p><strong>设备独立像素</strong>：设备独立像素，不同于设备像素（物理像素），它是虚拟化的。比如说css像素，我们常说的10px其实指的就是它。需要注意的是，<strong>物理像素</strong>开发者是无法获取的，它是自然存在的一种东西，该是多少就是多少。</p><p><strong>设备像素比</strong>：缩写简称<strong>dpr</strong>，也就是我们经常在谷歌控制台移动端调试顶端会看到的一个值。<strong>设备像素比</strong> = <strong>设备像素</strong> / <strong>css像素</strong>（垂直方向或水平方向）。可以通过JS来获取：<code>window.devicePixelRatio</code></p><h4 id="PC和移动端不同的视口"><a href="#PC和移动端不同的视口" class="headerlink" title="PC和移动端不同的视口"></a>PC和移动端不同的视口</h4><p><strong>注：以下涉及的像素均为CSS像素。并且默认不考虑缩放。</strong></p><p><strong>布局视口</strong></p><p>写过css的小伙伴应该知道，我们在<code>html</code>、<code>body</code>设置<code>width:100%;height:100%;</code>的时候，它并不是无效的。我们都知道<code>100%</code>这种百分数应该是继承父元素而来的。那在这里是继承哪里的呢？</p><p>在<strong>PC浏览器</strong>中，有一个用来约束CSS布局视口的东西，又叫做初始包含块。这也就是所有宽高继承的由来。除去<code>margin</code>、<code>padding</code>，布局视口和浏览器可视窗口宽度是一致的，同时也和浏览器本身的宽度一致。</p><p>但是在<strong>移动端</strong>，就大不一样了。</p><p>以下的例子是在不加<code>meta</code>标签的前提下进行演示的。</p><p>假如我们现在做一个二八分的左右布局，那么如果在PC端上面的话，显示的效果非常完美，这没什么好说的。</p><p>那如果是在手机端呢，这里以iphone6为例子来讲解：</p><p>图例如下：</p><p><img src="http://oxybu3xjd.bkt.clouddn.com/1508220097.png" alt="image"></p><p>代码如下：</p><pre><code>* {    margin: 0;    padding: 0;}html,body {    height: 100%;    width: 100%;}.left {    float: left;    width: 20%;    height: 100%;    background: red;}.right {    float: right;    width: 80%;    height: 100%;    background: green;}----&lt;body&gt;    &lt;div class=&quot;left&quot;&gt;&lt;/div&gt;    &lt;div class=&quot;right&quot;&gt;&lt;/div&gt;&lt;/body&gt;</code></pre><p>这里我们会看到，为什么<code>body</code>的高度是<code>980px</code>，而浏览器的宽度只有<code>375px</code>，那么这个<code>980px</code>到底是从哪里来的呢？</p><p>其实，这里的<code>980px</code>就是移动端所谓的<strong>布局视口</strong>了。</p><p>在移动端，默认的情况下，布局视口的宽度是要远远大于浏览器的宽度的。这两个视口不同于PC端，是<strong>相互独立存在</strong>的。为什么呢？试想一下，如果一个网页不对移动端进行适配，用户进行阅读的时候，如果默认情况下布局视口的宽度等于浏览器宽度，那是不是展示起来更加的不友好。也就是说，如果一个<code>div</code>的宽度为20%，那么它在布局视口宽度为<code>980px</code>的时候，展示给用户的像素还有196px，而如果宽度只有<code>375px</code>的情况下，宽度只有<code>75px</code>，展示的大小相差特别大。</p><p>所以，浏览器厂商为了让用户在小屏幕下网页也能够显示地很好，所以把布局视口宽度设置地很大，一般在<code>768px ~ 1024px</code>之间，最常见的宽度是<code>980px</code>。这个宽度可以通过<code>document.documentElement.clientWidth</code>得到。</p><p><strong>视觉视口</strong></p><p>对于视觉视口来说，这个东西是呈现给用户的，它是用户看到网页区域内CSS像素的数量。由于用户可以自行进行缩放控制，所以这个视口并不是开发者需要重点关注的。</p><p>值得注意的是，在<strong>移动端</strong>缩放不会改变布局视口的宽度，当缩小的时候，屏幕覆盖的css像素变多，视觉视口变大，反之亦然。</p><p>而在<strong>PC端</strong>，缩放对应布局宽度和视觉窗口宽度都是<strong>联动</strong>的。而浏览器宽度本身是固定的，无论怎么缩放都不受影响。</p><p>如果对上面的宽度还是很乱，那么这里有一个表格可以帮助你理清思路。</p><p>以下表格横向都以浏览器窗口的宽度作为基准：</p><p>对于PC端来说：<br><img src="http://oxybu3xjd.bkt.clouddn.com/1508220128.png" alt="image"></p><p>对于移动端来说：<br><img src="http://oxybu3xjd.bkt.clouddn.com/1508220121.png" alt="image"></p><p><strong>理想视口</strong></p><p>以上，布局视口很明显对用户十分的不友好，完全忽略了手机本来的尺寸。</p><p>所以苹果引入了理想视口的概念，它是对设备来说最理想的布局视口尺寸。理想视口中的网页用户最理想的宽度，用户进入页面的时候不需要缩放。</p><p>那么很明显，所谓的理想宽度就是浏览器（屏幕）的宽度了。</p><p>所以就有了下面的这段代码：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width&quot;&gt;</code></pre><p>然而，这段代码其实也并不完美，在IE浏览器中，由于横屏竖屏的切换会对其造成影响，为了解决这个兼容性的问题，最后再加上一句，就有了现在的：</p><pre><code>&lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1&quot;&gt;</code></pre><p><code>width=device-width</code> 这句代码可以把布局视口设置成为浏览器（屏幕）的宽度。</p><p><code>initial-scale=1</code> 的意思是初始缩放的比例是1，使用它的时候，同时也会将布局视口的尺寸设置为缩放后的尺寸。而缩放的尺寸就是基于屏幕的宽度来的，也就起到了和<code>width=device-width</code>同样的效果。</p><p>另外，值得一提的是，我们在进行媒体查询的时候，查询的宽度值其实也是布局视口的宽度值。</p><h3 id="Retina屏幕-amp-普通屏幕，模糊的由来"><a href="#Retina屏幕-amp-普通屏幕，模糊的由来" class="headerlink" title="Retina屏幕&amp;普通屏幕，模糊的由来"></a>Retina屏幕&amp;普通屏幕，模糊的由来</h3><h4 id="dpr的具体表现"><a href="#dpr的具体表现" class="headerlink" title="dpr的具体表现"></a>dpr的具体表现</h4><p>有时候我们会发现，当我们在适某一机型的时候，显示上没什么问题。但是一旦我换到另外一部手机，发现出现了模糊的情况，尤其以图片更为显著。</p><p>其实这个问题，就是涉及到了上面讲到的一个属性：<strong>设备像素比</strong>，即我们经常说的<strong>dpr</strong>。下面先来看<strong>dpr</strong>的表现：</p><p>假设现在有一台iphone6，那么它的设备独立像素是375x667，dpr为2，尺寸是4.7in，那么物理像素就是750x1334。<br>同样的我们也有一台不知名的设备，它的设备独立像素刚好也是375x667，尺寸也是4.7in，但是dpr为1，此时的物理像素就是375x667。</p><p>于是，它们的屏幕表现如下：</p><p><img src="http://oxybu3xjd.bkt.clouddn.com/1508220154.png" alt="image"></p><p>在不同的屏幕上，无论是普通屏幕还是retina屏幕，<strong>css像素所呈现的大小是一致的</strong>。（如果不理解这句话，可以写一个2px的正方形使用谷歌控制台移动设备调试，在不同的设备之间来回切换，你会发现大小其实是一样的。一开始我总以为这个css像素的实际宽高因为受到dpr的影响而在不同设备上的长宽是不一致的。）</p><p>不同的是，1个css像素对应（覆盖）的物理像素个数。</p><p>所以，如果我们想要在这两个屏幕显示这么一个css样式：</p><pre><code>width: 2px;heigth: 2px;</code></pre><p>在普通屏幕下，也就是dpr为1的屏幕中，1个css像素对应（覆盖）的是一个物理像素。在retina屏幕下，1个css像素对应（覆盖）的是4个物理像素。换句话说，就是dpr为2的设备。看下面这张图：</p><p><img src="http://oxybu3xjd.bkt.clouddn.com/1508220142.png" alt="image"></p><p>浅显的理解就是可以看作是2cmx2cm的正方形被切割成四块，然后遇到dpr为2的时候，被切割的四块又被分别切割成四块，但是总面积不变。</p><h4 id="模糊的产生"><a href="#模糊的产生" class="headerlink" title="模糊的产生"></a>模糊的产生</h4><p>知道了1个css像素覆盖的物理像素可能不同，就好理解为什么会出现模糊的情况了。</p><p>这里又讲到一个名词：<strong>位图像素</strong>。</p><p>位图像素是栅格图像（如：png,jpg,gif等）最小的数据单元。每一个位图像素都包含着一些自身的显示信息。（如：显示位置，颜色值，透明度等）</p><p>理论上来说，<strong>1个位图像素对应1个物理像素，图片才能等到完美清晰的展示</strong>。</p><p>但是上面说过，在retina屏幕上，会出现1个位图像素对应多个物理像素。</p><p>还是以iphone6为例，1个位图像素对应4个物理像素。由于单个位图像素已经是最小的数据单位了，它不能再被进行切割。于是为了能够显示出来，就只能就近取色，从而导致所谓的图片模糊问题。如下：</p><p><img src="http://oxybu3xjd.bkt.clouddn.com/1508220162.png" alt="image"></p><h4 id="如何解决"><a href="#如何解决" class="headerlink" title="如何解决"></a>如何解决</h4><p>很明显，由于位图像素不够分而产生模糊的情况，解决的办法十分简单，就是使用跟dpr同个倍数大小的图片。比如iphone6，一个200x300的<code>img</code>标签，原图就要提供400x600的大小。</p><p>那么当加载到<code>img</code>标签中，浏览器会自动对每1px的css像素减半，可以理解为此时还是维持着1:1的css像素:物理像素，不产生模糊。</p><p>这个做法其实就是手淘团队在做retina适配的一个重要的原理之一，后面会讲到，这里先放着不说。</p><h4 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h4><p>反向思考一下，如果普通屏幕，也就是dpr为1的屏幕，也使用了两倍的图片，会发生什么样的情况呢？</p><p>很明显，在普通屏幕下，200×300的<code>img</code>标签，所对应的物理像素个数就是200×300个，而两倍图片的位图像素个数则是200x300x4，所以就出现一个物理像素点对应4个位图像素点，所以它的取色也只能通过一定的算法进行缩减，显示结果就是一张只有原图像素总数四分之一，肉眼看上去虽然图片不会模糊，但是会觉得有点色差。（其实就是模糊的逆向过程）</p><p>用图片来表示就是：</p><p><img src="http://oxybu3xjd.bkt.clouddn.com/1508220171.png" alt="image"></p><p>这里摘取了网上一篇<a href="http://mobile.51cto.com/web-484304.htm" target="_blank" rel="external">博文</a>的demo来阐述上面所说的问题。</p><p><img src="http://oxybu3xjd.bkt.clouddn.com/1508220182.png" alt="image"></p><p>以上是一张100x100的图片，分别放在了100x100，50x50，25x25的容器中，在retina屏幕下面的显示效果。</p><p>通过取色器放大镜可以看出边界像素点的差别：</p><p>在图一中，边界像素点就近取色，色值介于红白之间，偏淡，图片看上去会模糊(可以理解为图片拉伸)。</p><p>在图二中，图片正常，很清晰。</p><p>在图三中，边界像素点就近取色，色值介于红白之间，偏浓，图片看上去有色差。</p><h3 id="手淘团队flexible-js布局"><a href="#手淘团队flexible-js布局" class="headerlink" title="手淘团队flexible.js布局"></a>手淘团队flexible.js布局</h3><p>现今，适配手机端的传统rem布局已经逐步被手淘团队的一套flexible布局代替。</p><p>具体的实现方式以及细节这里也不铺开来说，具体参考w3cplus的一篇<a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="external">文章</a>，很容易读懂和理解。</p><p>这里我更想分析一下flexible.js做法的意义和原因。</p><p>读过文章之后，相信大家应该对整个开发适配的流程比较熟悉了。</p><p>假设现在要适配一个iphone6的设备。上面已经说过了iphone6的各个参数，这里不再赘述，需要的自行上移查看。</p><p>于是：</p><ol><li>设计师给了一个750px宽度的设计稿（注意这里是750px而不是375px）</li><li>前端工程师用750px的这个比例开始还原</li><li>把宽高是px的转换成rem</li><li>字体使用px而不使用rem</li><li>flexible.js会自动判断dpr进行整个布局视口的放缩</li></ol><h4 id="rem布局和字体的处理"><a href="#rem布局和字体的处理" class="headerlink" title="rem布局和字体的处理"></a>rem布局和字体的处理</h4><p>从flexible.js中可见，在宽高中使用的是rem，这是为了保证在不同宽度尺寸的设备中能够保证布局的等比例缩放。</p><p>而为什么字体不使用rem而是采用px呢？</p><p>首先，用过rem单位的小伙伴都会发现，使用rem后由于不同的尺寸，换算之后出现各种奇奇怪怪的数值，最为明显的就是更多的小数位，比如<code>13.755px</code>之类的数值。在浏览器中，各浏览器中对小数点的计算存在偏差，而且有些带小数的<code>font-size</code>值在特定的浏览器显示并不够清晰。</p><p>其次，我们并不希望在小屏幕下面显示跟大屏幕同等量的字体。并且如果使用rem的话，那么由于等比例的存在，在小屏幕下就会存在小屏幕字体更小的情况，不利于我们更好的去阅读，违背了适配的初衷。所以，对于字体的适配，更好的做法就是使用px和媒体查询来进行适配。</p><p>所以，也就不难解释为什么要对<code>font-size</code>进行放大的处理了，如下的sass代码：</p><pre><code>@mixin font-dpr($font-size) {    font-size: $font-size;    [data-dpr=&quot;2&quot;] &amp; {        font-size: $font-size * 2;    }    [data-dpr=&quot;3&quot;] &amp; {        font-size: $font-size * 3;    }}</code></pre><p>由于retina屏幕下dpr的不同，我们又想显示的字体一样大，于是就给字体再增大dpr的倍数，这样当缩小dpr倍的时候，那么字体也就和设计稿所示的大小一样大了，在不同的手机中显示的大小也是一致的。</p><h4 id="Retina屏幕下的处理与安卓手机的适配"><a href="#Retina屏幕下的处理与安卓手机的适配" class="headerlink" title="Retina屏幕下的处理与安卓手机的适配"></a>Retina屏幕下的处理与安卓手机的适配</h4><p>从flexible.js的代码中可以知道，flexible布局仅仅只是针对iPhone进行适配，而默认所有的安卓设备都强制性设置dpr为1。</p><p>于是，因为这个缘故，很多小伙伴可能就会产生这样的问题：<strong>为什么安卓不用retina屏幕，安卓下面是不是就不会有模糊的问题？</strong></p><p>其实不然，<strong>模糊的本质是因为dpr</strong>，而安卓手机不同的设备的dpr也是不尽相同的。也就是说，安卓手机下也存在模糊的情况。只不过它的屏幕不叫retina屏幕，没有这个叫法，所以很多小伙伴都误认为安卓手机没有这个毛病。</p><p>那么问题又来了？既然也有模糊的毛病，那么为什么安卓手机不进行适配呢？</p><p>问题就在这里了，有兴趣的小伙伴可以去看一下大中华的安卓手机，dpr参数五花八门，从1到4，连1.75、2.75这种奇葩的数字也有，所以个人觉得权衡之下，直接简单“粗暴”把安卓手机全部设置为1，是效率和收益更高的做法。</p><p>当然，也有人进行了flexible.js的改进，就是对dpr比较正常的安卓手机进行适配，也就是说只适配dpr为整数的安卓设备。对于那些奇葩的dpr为1.75的设备直接忽略。实现这个并不难，有兴趣的小伙伴们可以试下。</p><h3 id="响应式与自适应的选择"><a href="#响应式与自适应的选择" class="headerlink" title="响应式与自适应的选择"></a>响应式与自适应的选择</h3><p>最后，对于响应式和自适应的区别，网上有各种各样的解释。</p><p>个人认为，其实没必要把它讲得那么复杂，知乎上有个小伙伴讲我觉得就很白话文：</p><blockquote><p>响应式针对的是不同分辨率设备而进行的适配式设计，以利用@media规则为主要手段，而自适应则忽略@media以比例布局为主，目的是适应不同的浏览器窗口大小。</p></blockquote><p>于是我们会发现，现今大型网站，例如说淘宝网，已经没有做响应式了。什么意思呢？</p><p>我们会发现，淘宝网手机端和网页端使用的是两个域名，也就是说，不同的客户端已经不再共用一套dom结构了。而是区分开来做自适应。然后每次用户访问的时候它就根据客户端的类型重定向。</p><p>为什么呢？</p><p>试想一下淘宝这种大型网站，一个分页下的商品条目特别多，并且每个商品条目的dom结构又十分复杂，而且pc端往往显示的信息是要比手机端更多的。如果不分开做两套，而是直接用响应式的话，那么pc端上显示的很多dom就要在手机端上隐藏，结果这些dom都没有被用到，但是却加载了。在这个流量和速度至上的时代，代码冗余先不说，多加载的这些无用的代码而消耗的流量，从某种意义上来说就已经损失了很多的效益。</p><hr><p>以上，就是本文的全部啦。</p><p>文章有借鉴，借鉴的链接都会在这里放出来。</p><p>前辈们的经验和知识很宝贵，我们需要做的，是站在巨人的肩膀上，去提炼这些东西，有自己更好的理解、思考和开拓新知识面。</p><p>相关链接：</p><p>移动端适配方案（主要讲解的是移动端视口方面的知识）：<br><a href="https://segmentfault.com/a/1190000004336869" target="_blank" rel="external">https://segmentfault.com/a/1190000004336869</a><br><a href="https://segmentfault.com/a/1190000004358316" target="_blank" rel="external">https://segmentfault.com/a/1190000004358316</a></p><p>Retina屏幕下模糊的由来：<br><a href="http://mobile.51cto.com/web-484304.htm" target="_blank" rel="external">http://mobile.51cto.com/web-484304.htm</a></p><p>手淘flexible.js布局：<br><a href="http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html" target="_blank" rel="external">http://www.w3cplus.com/mobile/lib-flexible-for-html5-layout.html</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;meta标签到底做了什么事情&quot;&gt;&lt;a href=&quot;#meta标签到底做了什么事情&quot; class=&quot;headerlink&quot; title=&quot;meta标签到底做了什么事情&quot;&gt;&lt;/a&gt;meta标签到底做了什么事情&lt;/h3&gt;&lt;p&gt;做过移动端适配的小伙伴一定有遇到过这行代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;&amp;lt;meta name=&amp;quot;viewport&amp;quot; content=&amp;quot;width=device-width, initial-scale=1.0&amp;quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;但是，很多小伙伴只是感性的认识：噢，我加了这行代码，然后页面的宽度就会跟我的设备宽度一致。然而，这种理解是很片面的。那么，这句话的本质到底是什么呢？&lt;/p&gt;
&lt;p&gt;不急，我们先往下面看，这里先留个悬念。&lt;/p&gt;
&lt;h4 id=&quot;几个专有名词和单位&quot;&gt;&lt;a href=&quot;#几个专有名词和单位&quot; class=&quot;headerlink&quot; title=&quot;几个专有名词和单位&quot;&gt;&lt;/a&gt;几个专有名词和单位&lt;/h4&gt;&lt;p&gt;这里，我们先来辨析一下在适配的时候经常会遇到的一些名词、数值单位。&lt;/p&gt;
&lt;p&gt;首先，先来看一下&lt;strong&gt;物理像素&lt;/strong&gt;。&lt;br&gt;
    
    </summary>
    
      <category term="移动端适配" scheme="https://devinnn.github.io/categories/%E7%A7%BB%E5%8A%A8%E7%AB%AF%E9%80%82%E9%85%8D/"/>
    
    
      <category term="flexible布局" scheme="https://devinnn.github.io/tags/flexible%E5%B8%83%E5%B1%80/"/>
    
      <category term="CSS" scheme="https://devinnn.github.io/tags/CSS/"/>
    
  </entry>
  
  <entry>
    <title>markdown样式预览（测试）</title>
    <link href="https://devinnn.github.io/article/2017/09/18/markdown%E6%A0%B7%E5%BC%8F%E9%A2%84%E8%A7%88/"/>
    <id>https://devinnn.github.io/article/2017/09/18/markdown样式预览/</id>
    <published>2017-09-18T06:12:34.000Z</published>
    <updated>2017-10-17T06:17:01.707Z</updated>
    
    <content type="html"><![CDATA[<h1 id="标题一"><a href="#标题一" class="headerlink" title="标题一"></a>标题一</h1><h2 id="标题二"><a href="#标题二" class="headerlink" title="标题二"></a>标题二</h2><h3 id="标题三"><a href="#标题三" class="headerlink" title="标题三"></a>标题三</h3><h4 id="标题四"><a href="#标题四" class="headerlink" title="标题四"></a>标题四</h4><h5 id="标题五"><a href="#标题五" class="headerlink" title="标题五"></a>标题五</h5><h5 id="标题六"><a href="#标题六" class="headerlink" title="标题六"></a>标题六</h5><p>段落： 这里是段落</p><p>无序列表：</p><ul><li>1<ul><li>123123</li></ul></li><li>2</li><li>3</li><li>4</li></ul><p>有序列表：</p><ol><li>123123123<ul><li>123123</li><li>123123</li></ul></li><li>1212313123</li></ol><p>引用：</p><blockquote><ol><li>123 </li><li>123</li></ol></blockquote><p>分割线： </p><hr><p>代码：</p><pre><code>p {    margin: 0;    padding: 0}---var a = 2;---&lt;h1&gt;hello&lt;/h1&gt;</code></pre><a id="more"></a><p>强调：<br><strong>123</strong></p><p><em>下划线</em></p><p>删除：<br><del>123</del></p><p>行内代码：<br><code>print</code></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;标题一&quot;&gt;&lt;a href=&quot;#标题一&quot; class=&quot;headerlink&quot; title=&quot;标题一&quot;&gt;&lt;/a&gt;标题一&lt;/h1&gt;&lt;h2 id=&quot;标题二&quot;&gt;&lt;a href=&quot;#标题二&quot; class=&quot;headerlink&quot; title=&quot;标题二&quot;&gt;&lt;/a&gt;标题二&lt;/h2&gt;&lt;h3 id=&quot;标题三&quot;&gt;&lt;a href=&quot;#标题三&quot; class=&quot;headerlink&quot; title=&quot;标题三&quot;&gt;&lt;/a&gt;标题三&lt;/h3&gt;&lt;h4 id=&quot;标题四&quot;&gt;&lt;a href=&quot;#标题四&quot; class=&quot;headerlink&quot; title=&quot;标题四&quot;&gt;&lt;/a&gt;标题四&lt;/h4&gt;&lt;h5 id=&quot;标题五&quot;&gt;&lt;a href=&quot;#标题五&quot; class=&quot;headerlink&quot; title=&quot;标题五&quot;&gt;&lt;/a&gt;标题五&lt;/h5&gt;&lt;h5 id=&quot;标题六&quot;&gt;&lt;a href=&quot;#标题六&quot; class=&quot;headerlink&quot; title=&quot;标题六&quot;&gt;&lt;/a&gt;标题六&lt;/h5&gt;&lt;p&gt;段落： 这里是段落&lt;/p&gt;
&lt;p&gt;无序列表：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1&lt;ul&gt;
&lt;li&gt;123123&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;2&lt;/li&gt;
&lt;li&gt;3&lt;/li&gt;
&lt;li&gt;4&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;有序列表：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;123123123&lt;ul&gt;
&lt;li&gt;123123&lt;/li&gt;
&lt;li&gt;123123&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;1212313123&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;引用：&lt;/p&gt;
&lt;blockquote&gt;
&lt;ol&gt;
&lt;li&gt;123 &lt;/li&gt;
&lt;li&gt;123&lt;/li&gt;
&lt;/ol&gt;
&lt;/blockquote&gt;
&lt;p&gt;分割线： &lt;/p&gt;
&lt;hr&gt;
&lt;p&gt;代码：&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;p {
    margin: 0;
    padding: 0
}
---
var a = 2;
---
&amp;lt;h1&amp;gt;hello&amp;lt;/h1&amp;gt;
&lt;/code&gt;&lt;/pre&gt;
    
    </summary>
    
      <category term="测试" scheme="https://devinnn.github.io/categories/%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="markdown样式预览" scheme="https://devinnn.github.io/tags/markdown%E6%A0%B7%E5%BC%8F%E9%A2%84%E8%A7%88/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript之原型链的解读</title>
    <link href="https://devinnn.github.io/article/2017/08/23/JavaScript%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
    <id>https://devinnn.github.io/article/2017/08/23/JavaScript原型链/</id>
    <published>2017-08-23T07:08:53.000Z</published>
    <updated>2017-10-17T03:22:54.310Z</updated>
    
    <content type="html"><![CDATA[<p>在<code>JavaScript</code>中，原型链作为一个基础，老生长谈，今天我们就来深入的解读一下原型链。</p><p>本章主要讲的是下面几点，可以根据需要进行阅读：</p><ul><li>函数与对象</li><li>对于<code>prototype</code>的认识</li><li>对于<code>__proto__</code>的的认识</li><li><code>prototype</code>和<code>__proto__</code>的关系</li><li><code>instanceof</code>操作符到底是怎么穿梭的</li><li><code>[[prototype]]</code>链属性的访问</li><li><code>[[prototype]]</code>链上的属性设置与属性屏蔽</li><li>关于<code>prototype</code>中的<code>constructor</code>属性<a id="more"></a></li><li>当我们在使用<code>new</code>的时候到底发生了什么</li><li>应用：两种继承的设计模式</li><li>函数与对象到底是什么关系</li></ul><h3 id="1-函数与对象"><a href="#1-函数与对象" class="headerlink" title="1. 函数与对象"></a>1. 函数与对象</h3><p>我们都知道，<code>JavaScript</code>中，一切都是对象，函数也是对象，数组也是对象，但是数组是对象的子集，而对于函数来说，函数与对象之间有一种“鸡生蛋蛋生鸡”的关系，这两者之间的关系是很难说清楚的，最后我们会详细的去总结它。</p><blockquote><ol><li>所有的对象<b>都是</b>由<code>Object</code>继承而来，而<code>Object</code>对象却是一个函数。</li><li>对象<b>都是</b>由函数来创建的。</li></ol></blockquote><p>对于上述的第一点，前半部分会在后面的解释中讲到，而对于后半部分，在控制台中输入<code>typeof Object</code>，显然输出的是<code>function</code>。</p><p>上述的第二点，我们可以看一下下面的例子。</p><pre><code>var obj = { a: 1, b: 2}var arr = [2, &#39;foo&#39;, false]</code></pre><p>表面上来看，好像不存在函数创建对象，而实际上，以上的过程是这样子的：</p><pre><code>var obj = new Object()obj.a = 1obj.b = 2var arr = new Array()arr[0] = 2arr[1] = &#39;foo&#39;arr[2] = false//typeof Object === &#39;function&#39;  //typeof Array === &#39;function&#39;</code></pre><h3 id="2-对于prototype的认识"><a href="#2-对于prototype的认识" class="headerlink" title="2. 对于prototype的认识"></a>2. 对于<code>prototype</code>的认识</h3><p>每一个<b>函数</b>都有一个属性叫做<code>prototype</code>，它的属性值是一个对象，在这个对象中默认有一个<code>constructor</code>属性，指向这个函数的本身。如下图：</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-d59e64eda47f78a8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-a40d4c9cce6f698f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="3-对于-proto-的的认识"><a href="#3-对于-proto-的的认识" class="headerlink" title="3. 对于__proto__的的认识"></a>3. 对于<code>__proto__</code>的的认识</h3><p><code>__proto__</code>是隐式原型，通常也写作<code>[[prototype]]</code>每一个<b>对象</b>都有一个这样的隐藏属性，<b>它引用了创建这个对象的函数的<code>prototype</code>。</b>（注：并不是所有浏览器都实现了对于对象的隐式原型的提供！）</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-db39bff123997686.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>需要注意的是，函数也是对象，自然它也有<code>__proto__</code>。</p><p>可见，<code>__proto__</code>和<code>prototype</code>并不相同（有例外，存在指向相同的情况），那两者有什么样的联系呢，继续往下看。</p><h3 id="4-prototype和-proto-的关系"><a href="#4-prototype和-proto-的关系" class="headerlink" title="4. prototype和__proto__的关系"></a>4. <code>prototype</code>和<code>__proto__</code>的关系</h3><p>前面我们讲到了两个很重要的点：</p><blockquote><ol><li>每一个<b>函数</b>都有一个属性叫做<code>prototype</code>，它的属性值是一个对象。</li><li>每一个<b>对象</b>都有一个隐式原型<code>__proto__</code>，它引用了创建这个对象的函数的<code>prototype</code>。</li></ol></blockquote><p>所以，下面让我们来看一段代码看看两者之间的关系：</p><pre><code>var o1 = new Object()var o2 = new Object()</code></pre><p>上面的<code>Object</code>作为构造函数创建了两个对象<code>o1</code>和<code>o2</code>。</p><p>看一下图解：</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-beef72dd5978da16.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>结合上面的两句话：</p><ol><li><code>function Object</code>在这里作为一个构造函数，毫无疑问它是一个函数，那么自然有一个<code>prototype</code>属性。</li><li><code>__proto__</code>引用了创建这个对象的函数的<code>prototype</code>。于是，<code>o1</code>和<code>o2</code>对象都是由<code>function Object</code> 创建出来的，那么自然的，它就指向（引用）了创建它们的函数(<code>Object</code>)的<code>prototype</code>属性。</li></ol><p>那我们再来看如果是一个普通的构造函数而不是内置的呢？一样的道理，这里我们就不再赘述。</p><pre><code>function foo() {}var f1 = new foo()var f2 = new foo()</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/5376626-2dc8bbfe17da7c57.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p><b>注意：这里有一个特例！</b><br>对于<code>Object.prototype</code>来说，它的<code>__proto__</code>是<code>null</code>，这是一个<b>特例。</b></p><p>同时，我们要注意图里面有一个<code>Foo.prototype</code>，它的<code>__proto__</code>指向了<code>Object.prototype</code>。这个是因为：<b>一切的对象都是由<code>Object</code>继承而来</b>，也就是说<code>Foo.prototype</code>这个对象也是由<code>Object</code>构造的，所以说<code>Foo.prototype.__proto__</code>指向（引用）了<code>Object.prototype</code>，这个也符合我们上面所述的<b>每一个<b>对象</b>都有一个隐式原型<code>__proto__</code>，它引用了创建这个对象的函数的<code>prototype</code></b>。</p><p>到这里，似乎<code>prototype</code>和<code>__proto__</code>关系已经很明朗的，但是你有没有发现还有一个坑，我们从头到尾都在围绕<code>function Object()</code>这个东西，那我们会不会考虑🤔这个鬼东西是从哪里来的呢？</p><p>难道凭空出现？显然，不存在的！毕竟，存在即合理。</p><p>那函数是怎么创建出来的呢？我们继续来看一段代码，这段代码可能你很少见，但是如果你读过红宝书函数的一章，你一定不会感到陌生！</p><pre><code>function foo(a, b) {  return a + b}console.log(foo(1, 2)) //3var boo = new Function(&#39;a&#39;, &#39;b&#39;, &#39;return a + b&#39;) //Function大写console.log(boo(1,2)) //3</code></pre><p>以上，第二种写法出现了大写的<code>Function</code>。（不推荐这么写。因为这是一种创建动态函数的写法，原因参考：<a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function" target="_blank" rel="external">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Function</a> ）</p><p>从上面的代码可知，函数是被<code>Function</code>创建的。</p><p>所以，<code>function Object</code>是由<code>Function</code>创建的，那么<code>Object.__proto === Function.prototype</code>也就不言而喻了，于是就有下面的一张图。</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-17cf9135fef993d2.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>在这张图中，<code>Foo</code>和<code>Object</code>这两个函数的<code>__proto__</code>就是指向<code>Function.prototype</code>了。</p><p>这里又有一个<b>特例</b>！（相信我，这是最后一个特例了🙄~）</p><p>没错，你会发现一个坑？为什么<code>Function.__proto__</code>指向了<code>Function.prototype</code>🤔？这又是什么操作？</p><p>我们来理一下思路：函数是由<code>Function</code>创建的，那么<code>Function</code>也是一个函数，那么它有没有可能是自己搞自己的呢😎？</p><p>答案是肯定的。</p><p>于是，函数是由<code>Function</code>创建的，那么<code>Function</code>由自身创建，所以<code>Function.__proto__</code>就指向了创建它的函数（也就是自己）的<code>prototype</code>。</p><p>那最后，把<code>Foo.prototype</code>、<code>Object.prototype</code>、<code>Function.prototype</code>的<code>__proto__</code>连起来，就可以得到下面这一张图。（红色标识即为特例）</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-8f56be1cb904b5e9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>最后，再次总结一下：</p><ul><li>所有的对象<b>都是</b>由<code>Object</code>继承而来，对象<b>都是</b>由函数来创建的。</li><li>每一个<b>函数</b>都有一个属性叫做<code>prototype</code>，它的属性值是一个对象。</li><li>每一个<b>对象</b>都有一个隐式原型<code>__proto__</code>，它引用了创建这个对象的函数的<code>prototype</code>。</li></ul><h3 id="5-instanceof操作符到底是怎么穿梭的"><a href="#5-instanceof操作符到底是怎么穿梭的" class="headerlink" title="5. instanceof操作符到底是怎么穿梭的"></a>5. <code>instanceof</code>操作符到底是怎么穿梭的</h3><p>既然讲到了<code>__proto__</code>和<code>prototype</code>，那么密不可分的就是<code>instanceof</code>操作符了。</p><blockquote><p>对于 <code>A instanceof B</code>来说，它的判断规则是：沿着<code>A</code>的<code>__proto__</code>这条线来找，同时沿着B的<code>prototype</code>这条线来找，如果两条线能找到同一个引用，即同一个对象，那么就返回<code>true</code>。如果找到终点还未重合，则返回<code>false</code>。</p></blockquote><p>所以，不熟悉的🙊就可以通过上面的那个总图来进行判断到底是返回<code>true</code>还是<code>false</code>。</p><p>那么，我们来举个🌰：</p><pre><code>function fn() {}var f1 = new fn();console.log(f1 instanceof Object);//trueconsole.log(f1 instanceof fn);//true</code></pre><p>显然，沿着链条穿梭成立！</p><p>再来看几个喜闻乐见的：</p><pre><code>console.log(Object instanceof Function);//trueconsole.log(Function instanceof Object);//trueconsole.log(Function instanceof Funciton);//true</code></pre><p>所以，<code>instanceof</code>操作符机制就不言而喻了。</p><h3 id="6-prototype-链属性的访问"><a href="#6-prototype-链属性的访问" class="headerlink" title="6. [[prototype]]链属性的访问"></a>6. <code>[[prototype]]</code>链属性的访问</h3><p>众所周知，<code>JavaScript</code>中的继承是通过<code>[[prototype]]</code>链来实现的（也叫原型链）。</p><p>看下面代码：</p><pre><code>function foo (){}var f1 = new foo()f1.a = 10foo.prototype.a=1foo.prototype.b=2console.log(f1.a) //10console.log(f1.b) //2console.log(f1.c) // undefined</code></pre><blockquote><p>访问一个对象的属性时，先在这个对象自身属性中查找，如果没有，再沿着<code>__proto__</code>这条链向上找，这就是<code>[[prototype]]</code>链（原型链），如果一直找不到，那么最后会返回<code>undefined</code>。</p></blockquote><p>那如何区分这个属性是实例对象中的（比如说上面<code>new</code>出来的对象<code>f1</code>）还是通过<code>[[prototype]]</code>链找到的呢？</p><p>答案就是<code>hasOwnProperty</code>，同时，在<code>for...in</code>循环中，要注意该遍历会遍历出包括原型的所有属性。</p><p>我们可以对上面代码的<code>a</code>和<code>b</code>进行检测：</p><pre><code>function foo (){}var f1 = new foo()f1.a = 10foo.prototype.a=1foo.prototype.b=2console.log(f1.a)//10console.log(f1.b)//2console.log(f1.hasOwnProperty(&#39;a&#39;)) //trueconsole.log(f1.hasOwnProperty(&#39;b&#39;)) //false</code></pre><p>在这里，本身<code>f1</code>是没有<code>hasOwnProperty</code>方法的，并且，<code>foo.prototype</code>也是没有的。那其实它是从<code>Object.prototype</code>中继承而来的。可见，<b><code>[[prototype]]</code>链最终的位置就是<code>Object.prototype</code></b>。以下是<code>Object.prototype</code>的一些属性和方法。</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-96439fdbea677924.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><h3 id="7-prototype-链上的属性设置与属性屏蔽"><a href="#7-prototype-链上的属性设置与属性屏蔽" class="headerlink" title="7. [[prototype]]链上的属性设置与属性屏蔽"></a>7. <code>[[prototype]]</code>链上的属性设置与属性屏蔽</h3><p>先来看一下这段代码：</p><pre><code>var parentObject = {  a: 1,  b: 2};var childObject = {};console.log(childObject); // &gt; Object {}childObject.__proto__ = parentObject;console.log(childObject); // &gt; Object {}childObject.c = 3;childObject.a = 2;console.log(parentObject); // Object {a: 1, b: 2}console.log(childObject); // &gt; Object {c: 3, a: 2}</code></pre><p>这是一个很简单的属性设置，但是其实里面存在着<code>[[prototype]]</code>链属性设置的机制🙃。</p><p>如下：</p><ul><li>如果属性<code>c</code>不是直接存于<code>childObject</code>上，<code>[[Prototype]]</code>链就会被遍历，如果<code>[[Prototype]]</code>链上找不到<code>c</code>，<code>c</code>这时就会被直接添加到<code>childObject</code>上。</li><li>如果这时属性<code>a</code>存在于原型链上层而不存在于<code>childObject</code>中，赋值语句<code>childObject.a = 2</code>却不会修改到<code>parentObjec</code>t中的<code>a</code>，而是直接把<code>a</code>作为一个新属性添加到了<code>childObject</code>上。</li></ul><p>于此同时，也就发生了属性屏蔽😭。</p><p>此时会发现，赋值完了以后，<code>parentObject</code>的<code>a</code>属性没有被修改，而<code>childObject</code>中新增了一个<code>a</code>属性，所以现在就会出现一个问题，<code>parentObject</code>的<code>a</code>属性再也不能通过<code>childObject.a</code>的方式被访问到了。</p><p>在这里，就发生了属性屏蔽，<code>childObject</code>中包含的<code>a</code>属性会屏蔽原型链上层所有的<code>a</code>属性，因为<code>childObject.a</code>总会选择原型链中最底层的<code>a</code>属性。</p><p>但实际上，屏蔽比我们想象中的更复杂。下面我们一起来分析一下<code>a</code>不直接存在于<code>childObject</code>中，而是存在于原型链上层时， 执行<code>childObject.a = 2</code>语句会出现的三种情况。</p><ol><li><p>如果在<code>[[Prototype]]</code>链上层存在名为<code>a</code>的普通数据访问属性，并且没有被标记为只读(<code>writable: false</code>)，那就会直接在<code>childObject</code>中添加一个名为<code>a</code>的新属性，它是屏蔽属性，这个情况就是上文例子中发生的情况。</p></li><li><p>如果在<code>[[Prototype]]</code>链上层存在<code>a</code>，但它被标记为只读(<code>writable: true</code>)，那么无法修改已有属性或者在<code>childObject</code>上创建屏蔽属性，严格模式下执行这个操作还会抛出错误。</p><pre><code> var parentObject = {};   Object.defineProperty(parentObject, &quot;a&quot;, {     value: 2,     writable: false, // 标记为不可写     enumerable: true //可遍历 }); var childObject = {     b: 3 }; childObject.__proto__ = parentObject; // 绑定原型 childObject.a = 10; console.log(childObject.a);  // 2 console.log(childObject);  // &gt; Object {b: 3} console.log(parentObject); // Object {a: 2}</code></pre></li><li><p>如果在<code>[[Prototype]]</code>链上层存在<code>a</code>并且它被定义成了一个<code>setter</code>函数，那就一定会调用这个<code>setter</code>函数。<code>a</code>不会被添加到<code>childObject</code>，上层的<code>setter</code>也不会被重新定义。</p><pre><code> var parentObject = {     set a(val) { //这是set函数，相当于赋值       this.aaaaaa = val * 2;     } }; var childObject = {     b: 3 }; childObject.__proto__ = parentObject; childObject.a = 10; console.log(childObject); //Object {b: 3, aaaaaa: 20} console.log(parentObject); //Object {}</code></pre></li></ol><p>另外，属性屏蔽还有一种很容易被忽略的情况😩：</p><pre><code>var parentObject = {    a: 2};var childObject = Object.create( parentObject ); // 这句话相当于先定义一个空对象，再绑定原型console.log(parentObject.a); // 2console.log(childObject.a); // 2console.log(parentObject.hasOwnProperty(&#39;a&#39;)); // trueconsole.log(childObject.hasOwnProperty(&#39;a&#39;)); // falseconsole.log(parentObject); // &gt; Object {a:2}childObject.a++;  // 这时候迭加的应是原型链上parentObject的aconsole.log(parentObject.a); // 2console.log(childObject) // &gt; Object { a: 3 }console.log(childObject.a); // 3console.log(childObject.hasOwnProperty(&#39;a&#39;)); // true</code></pre><p><code>childObject.a</code>访问的应是<code>parentObject</code>上的<code>a</code>属性，然而执行迭加后却产生了上面这个结果，原型链上的<code>a</code>并没有被修改到。 原因就是，在执行<code>childObject.a++</code>时，发生了隐式的属性屏蔽，因为<code>childObject.a++</code>实际上就相当于<code>childObject.a = childObject.a + 1</code>。</p><h3 id="8-关于prototype中的constructor属性"><a href="#8-关于prototype中的constructor属性" class="headerlink" title="8. 关于prototype中的constructor属性"></a>8. 关于<code>prototype</code>中的<code>constructor</code>属性</h3><p>上面有介绍说到<code>constructor</code>是函数原型的一个属性，指向函数的本身。</p><pre><code>function Foo() {  this.name = &#39;dog&#39;;}Foo.prototype.constructor === Foo; // truevar a = new Foo(); a.constructor === Foo; // true</code></pre><p>当<code>a.constructor === Foo</code>的时候，其实这时候并不能够说明<code>a</code>是由<code>Foo</code>构造而成的。实际上，<code>a.constructor</code>的引用是被委托给了<code>Foo.prototype</code>（本身<code>a</code>自身是没有这个属性的），所以才会出现等价的情况，而并不能说明<code>a</code>是由<code>Foo</code>构造而成的。</p><p>而对于<code>constructor</code>来说，这个属性其实就是<code>[[prototype]]</code>上一个简单的默认属性，没有<code>writable:false</code>也不是<code>setter</code>，只是有一个默认行为。</p><p>继续看下面的代码：</p><pre><code>function Foo() {  this.name = &#39;dog&#39;;}Foo.prototype = {  h: &#39;hhh&#39;};var a1 = new Foo();a1.constructor === Foo; // falsea1.constructor === Object; // truea1 instanceof Foo //true</code></pre><p>这里由于<code>Foo.prototype</code>的默认属性被清空了，所以<code>constructor</code>不存在，可是<code>__proto__</code>构成的原型链是不变的，所以<code>a1.constructor</code>的引用被委托到<code>Object.prototype.constructor</code>，所以第一个返回<code>false</code>，第二个返回<code>true</code>。</p><p>所以，我们应该怎么对待<code>constructor</code>这个属性呢😶？</p><p>它并不是什么神秘的属性，<code>Foo.prototype</code>的<code>constructor</code>属性只是<code>Foo</code>函数在声明时的默认属性。一定程度上可以用<code>.constructor</code>来判断原型指向，但它并不安全，除了有这个默认行为之外，<b>它和我们平常自定义的属性，再也没什么区别了。</b></p><h3 id="9-当我们在使用new的时候到底发生了什么"><a href="#9-当我们在使用new的时候到底发生了什么" class="headerlink" title="9. 当我们在使用new的时候到底发生了什么"></a>9. 当我们在使用<code>new</code>的时候到底发生了什么</h3><p>在<code>JavaScript</code>中，构造函数只是一些使用<code>new</code>操作符时被调用的函数，它们并不会属于某个类，也不会实例化一个类。所以，实际上并不存在所谓的“构造函数”，只有对于函数的“构造调用”。</p><p>当使用<code>new</code>来调用函数时，会自动执行以下操作：</p><ul><li>创建一个全新的对象</li><li>这个新对象会被执行<code>[[prototype]]</code>连接</li><li>这个新对象会绑定到函数调用的<code>this</code></li><li>如果函数没有返回其他对象，那么<code>new</code>表达式中的函数调用会自动返回这个新对象。</li></ul><p>看下面的例子：</p><pre><code>function SuperType(name) { // 定义了一个超类，供下面的子类继承    this.name = name;}function SubType() { // 定义了子类1，继承了超类，无返回值    SuperType.call(this, &quot;Cong1&quot;);    this.age = 29;  }function SubType2() { // 定义了子类2，继承了超类，返回了一个引用类型的值    SuperType.call(this, &quot;Cong2&quot;);    this.age = 29;    return { a: 2 };}function SubType3() { // 定义了子类3，继承了超类，返回了一个值类型的值    SuperType.call(this, &quot;Cong3&quot;);    this.age = 29;    return 3;}/* 下面比较有new操作符和无new操作符调用子类的区别 */var instance1_nonew = SubType();var instance2_nonew  = SubType2();var instance3_nonew = SubType3();var instance1_hasnew = new SubType();var instance2_hasnew = new SubType2();var instance3_hasnew = new SubType3();// 依次打印六个变量console.log(…);</code></pre><p>得到的结果是：</p><pre><code>instance1_nonewundefinedinstance2_nonew&gt; Object {a: 2}instance3_nonew3instance1_hasnew&gt; SubType {name: &quot;Cong1&quot;, age: 29}instance2_hasnew&gt; Object {a: 2}instance3_hasnew&gt; SubType3 {name: &quot;Cong3&quot;, age: 29}</code></pre><p>没有<code>new</code>操作符的语句，就像我们平常调用函数一样，得到的肯定是函数的返回值，所以前3个<code>_nonew</code>变量就会得到图示所示的结果。</p><p>而看到下面3个<code>_hasnew</code>变量，行为却有点不同，没有返回值的<code>1_hasnew</code>就直接构造了一个实例对象，而<code>2_hasnew</code>和<code>3_hasnew</code>都是有返回值的，两者的表现却不同了。</p><p>根据上面所说的原理再来分析一下这个过程：</p><ol><li>首先新建一个对象：<br><code>var instance = new Object()</code></li><li>给这个对象设置<code>[[prototype]]</code>链：<br><code>instance.__proto__ = SubType.prototype</code></li><li>绑定<code>this</code>，将<code>SubType</code>中的<code>this</code>指向<code>instance</code>，执行<code>SubType</code>中的语句进行赋值。</li><li>返回值，这里要根据<code>SubType</code>的返回类型来判断😷：<ul><li>如果是一个引用类型（对象），那么就替换掉<code>instance</code>本身的这个对象。（如：<code>instance2_hasnew</code>）</li><li>如果是值类型，那么直接丢弃它，返回<code>instance</code>对象本身。（如：<code>instance3_hasnew</code>）</li></ul></li></ol><h3 id="10-应用：两种继承的设计模式"><a href="#10-应用：两种继承的设计模式" class="headerlink" title="10. 应用：两种继承的设计模式"></a>10. 应用：两种继承的设计模式</h3><blockquote><p>在JavaScript中没有类的概念，更多的是使用原型继承。而这两种设计模式，一种是面向对象模式，而另外一种是对象关联模式。</p></blockquote><p>在使用的过程中，都用到了<code>Object.create()</code>，它会创建一个新对象并把它关联到我们指定的对象，也就是进行<code>[[prototype]]</code>连接。</p><ul><li>“原型”面向对象风格</li></ul><pre><code>function Foo(who) {    this.me = who}Foo.prototype.identify = function() {    return &quot;I am &quot; + this.me}function Bar(who) {    Foo.call(this,who)}Bar.prototype = Object.create(Foo.prototype)Bar.prototype.speak = function() {    console.log(&quot;Hello, &quot; + this.identify() + &quot;.&quot;)}var b1 = new Bar(&quot;b1&quot;)var b2 = new Bar(&quot;b2&quot;)b1.speak() //Hello, I am b1.b2.speak() //Hello, I am b2.</code></pre><p>关系图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-a580a38ce8549fa5.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><ul><li>对象关联风格</li></ul><pre><code>Foo = {    init: function(who) {        this.me = who    },    identify: function() {        return &quot;I am &quot; + this.me    }}Bar = Object.create(Foo)Bar.speak = function() {    console.log(&quot;Hello, &quot; + this.identify() + &quot;.&quot;)}var b1 = Object.create(Bar)b1.init(&quot;b1&quot;)var b2 = Object.create(Bar)b2.init(&quot;b2&quot;)b1.speak() //Hello, I am b1.b2.speak() //Hello, I am b2.</code></pre><p>关系图如下：</p><p><img src="http://upload-images.jianshu.io/upload_images/5376626-81057de8d93c3a22.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt=""></p><p>以上两种继承的设计，明显发现第二种更加的简洁。<br>在“原型面向对象风格”中，需要时刻的留意<code>prototype</code>的情况，<code>[[prototype]]</code>“游走”于函数的<code>prototype</code>之间。<br>而对于“对象关联风格”，它只关心一件事，那就是对象之间的关联情况，不将方法写于函数的<code>prototype</code>上。</p><p>虽然实现的原理是相同的，但是不同的思维方式，更利于理解，代码风格更为友好🤗。</p><h3 id="11-函数与对象到底是什么关系"><a href="#11-函数与对象到底是什么关系" class="headerlink" title="11. 函数与对象到底是什么关系"></a>11. 函数与对象到底是什么关系</h3><p>其实，这个问题也是困扰了我很久😪。</p><p>我们都知道：</p><ol><li>一切对象继承于<code>Object</code>。（当然<code>Object.prototype</code>除外）</li><li><code>Object.prototype.__proto__</code>指向了<code>null</code>。</li><li>对象都是由函数创建的。</li></ol><p>以上，看似并没有什么用，那现在我们来缕一下思路。</p><ol><li>（这里先不考虑<code>Object.prototype</code>）一切对象继承于<code>Object</code> ，所以说，对象的原型链（<code>__proto__</code>）最终的位置应该是<code>Object.prototype</code>。所以一切的老大应该是<code>Object.prototype</code>。</li><li><code>Object.prototype.__proto__</code>指向了<code>null</code>。既然<code>__proto__</code>的指向是创建这个对象的函数原型，可是这里<code>Object.prototype.__proto__</code>却指向了<code>null</code>。那么，唯一可能就是<code>Object.prototype</code>是由<code>JavaScript</code>引擎创造出来的。</li><li>所以，<b>最终<code>[[prototype]]</code>链的位置应该是<code>null</code>而不是<code>Object.prototype</code></b>。</li><li>对象都是由函数创建的。（这里的对象同样是不考虑<code>Object.prototype</code>的）也就是说，所有的对象都是由<code>Function</code>构造出来，那么他们的<code>[[prototype]]</code>都应该经过<code>Function.prototype</code>。</li><li>于是，引用类型等构造函数（如：<code>Array()</code>、<code>Object()</code>等）以及普通的函数对象，甚至<code>Function</code>，他们的<code>__proto__</code>应该是指向<code>Function.prototype</code>。</li><li>那<code>Function.prototype</code>的<code>__proto__</code>指向了哪里？由第一点可知，当然是指向了<code>Object.prototype</code>，所以<code>Function.prototype</code>就是老二。</li></ol><p>所以，简而言之：</p><ul><li>首先有的应该是<code>Object.prototype</code>，它是由<code>JavaScript</code>引擎创造出来的。</li><li>紧接着才有<code>Function.prototype</code>，并把它的<code>__proto__</code>连接到了<code>Object.prototype</code>。</li><li>接下来，将各种内置引用类型的构造函数的<code>__proto__</code>连接到了<code>Function.prototype</code>。</li><li>执行<code>Function.__proto__</code>连接到<code>Function.prototype</code>的操作。</li><li>执行<code>Object.__proto__</code>连接到<code>Object.prototype</code>的操作。</li><li>最后再是对<code>Function</code>和<code>Object</code>实例的挂载。</li></ul><p>注：以上为个人的见解，欢迎指正😉。</p><hr><p>😉这是一条可爱的分割线😉。</p><p>以上，就是本次博客的全部内容~（终于结束了）~感谢你耐心的阅读😉<br>第一次写博客，如有理解错误的地方，师请改正😳。</p><p>参考资料：<br>  书籍：《你不知道的JavaScript（上卷）》<br>  博客：<a href="http://www.cnblogs.com/wangfupeng1988/p/4001284.html" target="_blank" rel="external">http://www.cnblogs.com/wangfupeng1988/p/4001284.html</a><br>  博客：<a href="http://www.yangzicong.com/article/1" target="_blank" rel="external">http://www.yangzicong.com/article/1</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在&lt;code&gt;JavaScript&lt;/code&gt;中，原型链作为一个基础，老生长谈，今天我们就来深入的解读一下原型链。&lt;/p&gt;
&lt;p&gt;本章主要讲的是下面几点，可以根据需要进行阅读：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;函数与对象&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;prototype&lt;/code&gt;的认识&lt;/li&gt;
&lt;li&gt;对于&lt;code&gt;__proto__&lt;/code&gt;的的认识&lt;/li&gt;
&lt;li&gt;&lt;code&gt;prototype&lt;/code&gt;和&lt;code&gt;__proto__&lt;/code&gt;的关系&lt;/li&gt;
&lt;li&gt;&lt;code&gt;instanceof&lt;/code&gt;操作符到底是怎么穿梭的&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[prototype]]&lt;/code&gt;链属性的访问&lt;/li&gt;
&lt;li&gt;&lt;code&gt;[[prototype]]&lt;/code&gt;链上的属性设置与属性屏蔽&lt;/li&gt;
&lt;li&gt;关于&lt;code&gt;prototype&lt;/code&gt;中的&lt;code&gt;constructor&lt;/code&gt;属性
    
    </summary>
    
      <category term="JavaScript基础" scheme="https://devinnn.github.io/categories/JavaScript%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="JavaScript" scheme="https://devinnn.github.io/tags/JavaScript/"/>
    
  </entry>
  
</feed>
